


tirar variavel IDs
fazer o shap funcionar





fazer as analises novamente, do variable selection, ajustar para usar campos 
novos para melhorar a acuracia, fazer o variable selection funcionar para gerar os 5 primeiros
arrumar o model para fazer as analises com base nos pontos, ou pedir pro gepeto pensar o melor jeito de 
fazer as analises para prever o vencedor de 2025



faça uma analise tambem da posição de largada e posição de chegada para melhorar a acuracia

use o status, para ver se teve alguma coisa que quebrou no carro, use para verificar se o carro é 
confiavel, um carro confiavel tem mais chance de ganhar corridas

fastlaptime e fastestlapspeed devem ser usados para verificar quão bom é o carro, 

q1 q2 q3 são tempos de volta, o mais rapido é o que larga na primeira posição, então se o carro
 tem o menor tempo que esta em milissegundos ele é o mais rapido na pista, é o que tem o menor 
 tempo de volta, ou seja o melhor carro na pista, ou seja um carro que tem mais chance de ganhar, 
 tambem tem que usar a idade do piloto para ver a experiencia, um piloto mais velho no melhor carro 
 contra um piloto muito novo no mesmo carro, o mais velho com muita chance vai ganhar


colunas_finais = [ 'raceId', 'grid', 'position', 'points', 'year', 'name_circuits', 'country', 'driverRef', 'number_drivers', 'code', 'nationality_driver', 'dob', 'name_constructors', 'nationality_constructors', 'status', 'regulamento', 'fastestLapTime', 'fastestLapSpeed', 'rank', 'time', 'fp1_time', 'fp2_time', 'fp3_time', 'quali_time', 'sprint_time', 'q1', 'q2', 'q3' ]

essas são as colunas novas 

O objetivo do projeto é analisar o desempenho dos pilotos e das equipes de F1 com base em uma série de variáveis de tempo e desempenho. O modelo de machine learning deve usar dados sobre o desempenho do piloto durante a temporada de F1, levando em consideração tanto a experiência do piloto quanto os tempos de volta em diversas condições (treinos livres, classificatórios e corridas).

Objetivo principal:

Comparar a performance das equipes em termos de tempos mais rápidos e consistência de volta, incluindo as sessões de treino (FP1, FP2, FP3), qualificatório (Q1, Q2, Q3), e corrida.

Analisar o impacto da experiência do piloto na performance ao longo de uma temporada.

Informações relevantes para análise:

Experiência do piloto:

O campo 'dob' (Data de Nascimento) pode ser utilizado para calcular a idade do piloto, permitindo uma análise de sua experiência ao longo do tempo. Isso pode ajudar a comparar pilotos mais experientes com novatos, considerando que pilotos mais experientes podem ter uma maior consistência de performance.

A experiência também pode ser ligada à análise de desempenho histórico, comparando a performance de um piloto nas últimas temporadas e correlacionando com o desempenho atual.

Desempenho das equipes:

'fastestLapTime' e 'fastestLapSpeed': Esses dados podem ser usados para avaliar a performance do carro, comparando quais equipes conseguem produzir tempos mais rápidos nas corridas ou durante os treinos. Isso também pode ajudar a prever a chance de vitória de uma equipe com base na pole position ou na consistência de tempo de volta.

Os tempos de FP1, FP2, FP3 e quali_time são indicativos de como a equipe ajusta seu carro durante o fim de semana de corrida. Analise os dados desses tempos para ver qual equipe apresenta os melhores desempenhos em cada sessão, pois o desempenho durante os treinos pode ser indicativo do que esperar nas fases seguintes.

A análise do tempo de sprint_time também pode ajudar a identificar como os pilotos lidam com corridas mais curtas e intensas.

Análise de Qualificação:

A sequência dos tempos Q1, Q2, Q3 fornece um claro indicador do desempenho do piloto no classificatório. A posição de largada (grid) é um fator crucial para a probabilidade de vitória, já que, geralmente, quem larga mais à frente tem maior chance de vencer.

É importante considerar as margens de tempo entre os pilotos nessas sessões, especialmente em relação ao tempo final (pole position) em comparação com o resto do grid.

Influência do Status do Piloto:

O campo 'status' pode indicar se o piloto estava em boa forma física ou teve algum tipo de problema durante o evento (como uma punição ou uma falha técnica). Isso pode afetar a performance do piloto durante a corrida e deve ser levado em consideração nas análises preditivas.

Informações adicionais que podem melhorar a acurácia do modelo:

Dados históricos: O modelo pode se beneficiar de informações históricas, como os resultados das últimas corridas, classificações anteriores, e o histórico de desempenho dos pilotos e equipes nas mesmas condições de pista ou nas mesmas corridas.

Posição final e número de pontos: Para prever o desempenho de longo prazo de pilotos e equipes, é importante analisar os pontos acumulados ao longo da temporada e como a posição final na corrida impacta a pontuação do campeonato.

Variáveis chave a serem consideradas no modelo:

Tempos de volta em treinos livres (FP1, FP2, FP3)

Tempos de volta em qualificações (Q1, Q2, Q3)

Pole Position (baseado em 'quali_time')

Desempenho histórico (experiência do piloto e resultados passados)

Desempenho em sprints e corridas curtas (sprint_time)

'fastestLapTime' e 'fastestLapSpeed'

Punições e 'status'

Número de pontos acumulados na temporada

Posição no grid (baseado em 'grid')

Essa análise ajudará a otimizar o modelo de aprendizado de máquina, fornecendo uma visão mais precisa e detalhada sobre as chances de cada piloto e equipe durante uma temporada de F1.

faça todas as alteraçoes necessarias



import pandas as pd
import numpy as np
from datetime import datetime
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import StandardScaler, OneHotEncoder
from sklearn.model_selection import train_test_split
from sklearn.compose import ColumnTransformer
from sklearn.ensemble import GradientBoostingRegressor, RandomForestRegressor
from sklearn.metrics import mean_absolute_error
from lightgbm import LGBMRegressor

# -------------------- Funções de Pré-Processamento --------------------

def load_data(file_path: str) -> pd.DataFrame:
    """Carrega os dados e valida a presença da coluna 'points'."""
    data = pd.read_csv(file_path)
    if 'points' not in data.columns:
        raise ValueError("A coluna 'points' não foi encontrada.")
    return data

def preprocess_data(data: pd.DataFrame, target: str) -> tuple:
    """Pré-processa os dados e separa variáveis independentes e dependentes."""
    if target not in data.columns:
        raise ValueError(f"A coluna '{target}' não foi encontrada.")
    if 'dob' not in data.columns or 'status' not in data.columns:
        raise ValueError("As colunas 'dob' e 'status' são obrigatórias.")

    data['idade'] = data['dob'].apply(lambda dob: datetime.now().year - datetime.strptime(dob, '%Y-%m-%d').year - ((datetime.now().month, datetime.now().day) < (datetime.strptime(dob, '%Y-%m-%d').month, datetime.strptime(dob, '%Y-%m-%d').day)))
    data['carro_confiavel'] = data['status'].apply(lambda x: 1 if x == 'Running' else 0)
    data['melhor_temporada'] = data[['q1', 'q2', 'q3']].min(axis=1)
    data.fillna(0, inplace=True)

    X = data.drop(columns=[target, 'dob', 'time'])
    return X, data[target]

def aggregate_teams_data(data: pd.DataFrame) -> pd.DataFrame:
    """Agrega dados por temporada e equipe, mantendo 'points' e criando 'total_points'."""
    equipes_agrupadas = data.groupby(['year', 'name_constructors']).agg({'points': 'sum'}).rename(columns={'points': 'total_points'}).reset_index()
    equipes_agrupadas = equipes_agrupadas.merge(data[['year', 'name_constructors', 'points', 'dob', 'status', 'q1', 'q2', 'q3', 'fastestLapTime', 'fastestLapSpeed', 'grid', 'position', 'time']], on=['year', 'name_constructors'], how='left').drop_duplicates()
    return equipes_agrupadas

def calculate_growth_rate(data: pd.DataFrame) -> pd.DataFrame:
    """Calcula a taxa de crescimento dos pontos e substitui valores infinitos ou NaN por 0."""
    data['taxa_crescimento'] = data.groupby('name_constructors')['points'].pct_change().fillna(0).replace([np.inf, -np.inf], 0)
    return data

def create_performance_features(data: pd.DataFrame) -> pd.DataFrame:
    """Cria novas variáveis de desempenho para equipes e corridas."""
    corridas_por_ano = data.groupby('year').size().mean()
    data['media_pontos_por_corrida'] = data['points'] / corridas_por_ano
    data['media_pontos_por_corrida'].fillna(0, inplace=True)
    return data

# -------------------- Funções de Treinamento e Previsão --------------------

def validate_data(X: pd.DataFrame):
    """Valida dados de entrada para garantir que não contenham NaN ou valores nulos."""
    if X.isnull().any().any():
        raise ValueError("Os dados contêm valores NaN ou null.")

def create_pipeline(preprocessor: ColumnTransformer, model) -> Pipeline:
    """Cria o pipeline de pré-processamento e classificação com o modelo fornecido."""
    return Pipeline([('preprocessor', preprocessor), ('clf', model)])

def train_model_sklearn(data: pd.DataFrame, target: str):
    """Treina múltiplos modelos de regressão e seleciona o melhor baseado no erro absoluto médio."""
    X, y = preprocess_data(data, target)
    numeric_features = X.select_dtypes(include=['int64', 'float64']).columns
    categorical_features = X.select_dtypes(include=['object']).columns
    preprocessor = ColumnTransformer([
        ('num', StandardScaler(), numeric_features),
        ('cat', OneHotEncoder(handle_unknown='ignore'), categorical_features)
    ])
    
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=123)
    candidates = {
        'gradient_boosting': GradientBoostingRegressor(random_state=123),
        'random_forest': RandomForestRegressor(random_state=123),
        'lightgbm': LGBMRegressor(random_state=123, n_jobs=-1)
    }
    
    best_model = None
    best_score = np.inf

    
    for model in candidates.values():
        pipeline = create_pipeline(preprocessor, model)
        pipeline.fit(X_train, y_train)
        y_pred = pipeline.predict(X_test)
        score = mean_absolute_error(y_test, y_pred)
        if score < best_score:
            best_score = score
            best_model = pipeline
    
    print(f"Melhor modelo: {best_model.steps[-1][1].__class__.__name__} | Acurácia: {best_score:.4f}")
    return best_model, preprocessor

def predict_2025(modelo_equipes, preprocessor_equipes):
    """Faz previsões para a temporada de 2025 usando o modelo treinado."""
    dados_2025_equipes = pd.DataFrame({
        'year': [2025], 
        'media_pontos_por_corrida': [10], 
        'taxa_crescimento': [0.05], 
        'carro_confiavel': [1],
        'melhor_temporada': [150000], 
        'fastestLapSpeed': [210], 
        'posicao_largada': [1], 
        'posicao_chegada': [1],
        'idade': [32], 
        'total_points': [0], 
        'regulamento': ['default'], 
        'position': [1], 
        'fastestLapTime': [0],
        'name_constructors': ['default_team'], 
        'q1': [0], 'q2': [0], 'q3': [0], 
        'carro_rapido': [0], 
        'status': ['Running'], 
        'grid': [1]
    })
    
    dados_2025_equipes = dados_2025_equipes[preprocessor_equipes.feature_names_in_]
    dados_2025_equipes_transformed = preprocessor_equipes.transform(dados_2025_equipes)
    equipe_vencedora = modelo_equipes.predict(dados_2025_equipes_transformed)

    print(f"Equipe vencedora prevista para 2025: {equipe_vencedora[0]}")

    return equipe_vencedora

def run_pipeline(file_path: str):
    """Executa o pipeline de treinamento e previsão."""
    data = load_data(file_path)
    equipes = aggregate_teams_data(data)
    equipes = calculate_growth_rate(equipes)
    equipes = create_performance_features(equipes)
    modelo_equipes, preprocessor_equipes = train_model_sklearn(equipes, target='points')
    return modelo_equipes, preprocessor_equipes
